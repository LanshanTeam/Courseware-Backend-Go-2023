# 微服务入门

## 单体应用

与微服务相对的另一个概念是传统的「单体式应用程序」( Monolithic application )，单体式应用内部包含了所有需要的服务。而且各个服务功能模块有很强的耦合性，也就是相互依赖彼此，很难拆分和扩容。

### 单体应用的优点

- 开发简洁，功能都在单个程序内部，便于软件设计和开发规划。
- 容易部署，程序单一不存在分布式集群的复杂部署环境，降低了部署难度。
- 容易测试，没有各种复杂的服务调用关系，都是内部调用方便测试。

### 单体应用的缺点

单体架构随着功能增多，不可避免的是研发效能的降低：研发周期变长、研发资源占用增多。从而引发的情况是：新员工培训时间增多、员工加班时间变长、员工要求涨薪或者跳槽。到了这种情况就说明，单体架构已经不能够满足企业发展需要，这个时候，需要升级架构来提升研发效能，比如微服务架构。

## 微服务

> 2014年，[Martin Fowler](https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FMartin_Fowler) 与 [James Lewis](https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fw%2Findex.php%3Ftitle%3DJames_Lewis%26action%3Dedit%26redlink%3D1) 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通信。同时服务会使用最小的规模的集中管理 (例如 [Docker](https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FDocker)) 能力，服务可以用不同的编程语言与数据库等组件实现 。「维基百科」

微服务是一种架构风格：

1. 一组小服务
2. 每个服务运行在独立进程中
3. 服务之间使用轻量级通信
4. 服务可独立部署
5. 是基于业务能力实现
6. 无集中式管理

业界对于微服务还有一句更加剪短的描述：**微服务是一组小而自治的服务**。

### 微服务优点

优点很多，我们介绍几个比较重要的。

#### 隔离性

一个服务不可用不会导致另一个服务也瘫痪，因为各个服务是相互独立和自治的系统。这在单体应用程序中是做不到的，单体应用程序中某个模块瘫痪，必将导致整个系统不可用，当然，单体程序也可以在不同机器上部署同样的程序来实现备份，不过，同样存在上面说的资源浪费问题。

#### 可扩展性

庞大的单体服务如果出现性能瓶颈只能对软件整体进行扩展，可能真正影响性能的只是其中一个很小的模块，我们也不得不付出升级整个应用的代价。这在微服务架构中得到了改善，你可以只对那些影响性能的服务做扩展升级，这样对症下药的效果是很好的。

#### 简化部署

如果你的服务是一个超大的单体服务，有几百万行代码，即使修改了几行代码也要重新编译整个应用，这显然是非常繁琐的，而且软件变更带来的不确定性非常高，软件部署的影响也非常大。在微服务架构中，各个服务的部署是独立的，如果真出了问题也只是影响单个服务，可以快速回滚版本解决。

#### 易优化

微服务架构中单个服务的代码量不会很大，这样当你需要重构或者优化这部分服务的时候，就会容易很多，毕竟，代码量越少意味着代码改动带来的影响越可控。

### 微服务缺点

任何技术都存在它的弊端，没有弊端就没有新型技术的演进。

服务的拆分和定义是一种挑战。拆分服务是一项具备艺术的行为，因其本身就没有一个具体、良好的定义的模板或者算法来协助我们的拆分工作。

分布式系统带来的各种复杂性。采用这项模式之后，我们依然需要考虑它的复杂性，比如测试、事务、部署模式、通讯、网关、服务发现、可靠性、安全，可观测性（日志、审计、跟踪，健康检查）等等一系列额外的任务需要做。

### 微服务拆分原则

在我看来，微服务拆分其实目前来说没有确定的原则和标准可以参考，我们进行服务拆分时可以参考以下几个方面：

按业务功能拆分：将整个系统按照不同的业务模块进行拆分，每个模块对应一个微服务。这种方式能够有效地降低系统的复杂度，提高系统的可维护性和可扩展性。

按数据拆分：将整个系统的数据按照不同的领域进行拆分，每个领域对应一个微服务。这种方式能够提高系统的性能和可扩展性。

按用户界面拆分：将整个系统按照不同的用户界面进行拆分，每个用户界面对应一个微服务。这种方式能够实现快速迭代和响应用户需求的能力。

按技术栈拆分：将整个系统按照不同的技术栈进行拆分，每个技术栈对应一个微服务。这种方式能够提高开发效率和降低系统的复杂度。

按性能拆分：将整个系统按照不同的性能需求进行拆分，每个需求对应一个微服务。这种方式能够提高系统的性能和可扩展性。

## RPC

### 什么是RPC

![img](https://github.com/LanshanTeam/Courseware-Backend-Go-2022/raw/main/class11-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8ERPC%E6%A1%86%E6%9E%B6/images/rpc.jpg)

RPC是指远程过程调用,是Remote Procedure Call三个单词的缩写，功能就是本地的函数一样去调远程函数，远程一般是指通过网络从远程计算机程序上请求服务，也可以在在宿主机下通过网络进行不同架构下的互相请求服务。

RPC在分布式或者微服务架构上非常常用，RPC让不同服务之间的服务调用像本地调用一样简单高效，RPC是一种网络协议，是一种规范，每个大厂几乎都有自己研发的RPC协议。

### 为什么要用RPC

如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着。

当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。

当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 互，以此来完成完整的业务功能。

所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，服务之间的调用需要各种场景和因素的考虑，内部原理非常复杂和繁琐，同时在集群情况下，服务的负载均衡，熔断，限流等都是需要去考虑的，这时候就需要一个集服务注册发现、负载均衡、序列化协议、RPC通信协议、Socket通信、异步调用、熔断降级等技术为一体的技术去完成这些公共功能，所以你看，RPC大显身手的时候来了！

其实描述的场景也是服务化 、微服务和分布式系统架构的基础场景。即RPC框架就是实现以上结构的有力方式。

### 为什么不用HTTP

![img](https://github.com/LanshanTeam/Courseware-Backend-Go-2022/raw/main/class11-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8ERPC%E6%A1%86%E6%9E%B6/images/rpc-framework-vs-rest.webp)

为什么有HTTP还需要RPC呢？RPC那么复杂为什么不用HTTP请求.

首先需要指正，这两个并不是并行概念。RPC 是一种**设计**，就是为了解决**不同服务之间的调用问题**，完整的 RPC 实现一般会包含有 **传输协议** 和 **序列化协议** 这两个。

而 HTTP 是一种传输协议，RPC 框架完全可以使用 HTTP 作为传输协议，也可以直接使用 TCP，使用不同的协议一般也是为了适应不同的场景。

RPC主要是为了解决特定的问题或者节约成本的角度出发的。

使用 TCP 和使用 HTTP 各有优势：

**传输效率**：

- TCP，通常自定义上层协议，可以让请求报文体积更小
- HTTP：如果是基于HTTP 1.1 的协议，请求中会包含很多无用的内容

**性能消耗**，主要在于序列化和反序列化的耗时

- TCP，可以基于各种序列化框架进行，效率比较高
- HTTP，大部分是通过 json 来实现的，字节大小和序列化耗时都要更消耗性能

**跨平台**：

- TCP：通常要求客户端和服务器为统一平台
- HTTP：可以在各种异构系统上运行

**总结**： RPC 的 TCP 方式主要用于公司内部的服务调用，性能消耗低，传输效率高。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。

### 框架需要解决的问题

![img](https://github.com/LanshanTeam/Courseware-Backend-Go-2022/raw/main/class11-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8ERPC%E6%A1%86%E6%9E%B6/images/discovery-problem.jpg)

RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于**不在一个内存空间，不能直接调用**，需要通过网络来表达调用的语义和传达调用的数据。

比如说，一个方法可能是这样定义的：func GetUserProfile(userId int64) *Profile 那么：

第一，**首先，要解决通讯的问题**，主要是通过在客户端和服务器之间建立TCP连接（socket），远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。

第二，**要解决寻址的问题**，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。

第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是**序列化**（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。

第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。

第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用

**总的来说可以归纳为以下几步：**

1. 远程服务之间建立通讯协议
2. 寻址：服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么
3. 通过序列化和反序列化进行数据传递
4. 将传递过来的数据通过java反射原理定位接口方法和参数
5. 暴露服务：用map将寻址的信息暴露给远方服务（提供一个endpoint *URI或者一个前端展示页面*）
6. 多线程并发请求业务

### 基本组成

![img](https://github.com/LanshanTeam/Courseware-Backend-Go-2022/raw/main/class11-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8ERPC%E6%A1%86%E6%9E%B6/images/service-discovery.png)

RPC框架需要的最基本的三个要素：

- ServiceProvider: 服务提供方，提供相关服务接口。
- ServiceConsumer: 服务消费方，消费服务提供方的接口。
- Registry: 注册中心，用于进行服务的注册、发现、治理、高可用。

#### 注册中心

注册中心是RPC框架中的管理者和协调者角色，虽然在远程过程调用中服务消费者会不经过注册中心，会直接向服务提供者发送请求，但是随着我们的服务方越来越多，每个服务的实例也不断变化的，且每个服务的地址，端口等信息是需要通知到消费方的，所以我们需要一个类似“管家”的角色，来负责管理服务注册和发现的工作，这个“管家”我们称之为注册中心。

一个合格的注册中心需要具备包括缓存和持久化服务提供方数据，动态更新服务提供者信息，动态监听服务提供方节点变化，推送节点变化到消费方，查询服务提供方数据等功能。

#### 服务提供方（RPC服务端）

其需要对外提供服务接口，一个服务方需要包括启动连接注册中心，注册相关信息到注册中心，提供服务下线和更新机制，维护服务名和服务的映射，序列化和反序列化，启动通信等。

#### 服务消费方（RPC客户端）

服务消费方需要具备可以从注册中心拉取服务列表，缓存服务列表，动态监听和更新服务列表的功能，还需要具备针对于服务的负载均衡策略，序列化和反序列化，根据约定的通信协议进行调用等。

### 服务注册与发现

简单来说，当服务A需要依赖服务B时，我们就需要告诉服务A，哪里可以调用到服务B，这就是服务注册发现要解决的问题。

![img](https://github.com/LanshanTeam/Courseware-Backend-Go-2022/raw/main/class11-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8ERPC%E6%A1%86%E6%9E%B6/images/service-discovery.png)

- `Service B` 把自己注册到 `Service Registry` 叫做 **服务注册**
- `Service A` 从 `Service Registry` 发现 `Service B` 的节点信息叫做 **服务发现**

#### 服务注册

服务注册是针对服务端的，服务启动后需要注册，分为几个部分：

- 启动注册
- 定时续期
- 退出撤销

##### 启动注册

当一个服务节点起来之后，需要把自己注册到 `Service Registry` 上，便于其它节点来发现自己。注册需要在服务启动完成并可以接受请求时才会去注册自己，并且会设置有效期，防止进程异常退出后依然被访问。

##### 定时续期

定时续期相当于 `keep alive`，定期告诉 `Service Registry` 自己还在，能够继续服务。

##### 退出撤销

当进程退出时，我们应该主动去撤销注册信息，便于调用方及时将请求分发到别的节点。同时，go-zero 通过自适应的负载均衡来保证即使节点退出没有主动注销，也能及时摘除该节点。

### 服务发现

服务发现是针对调用端的，一般分为两类问题：

- 存量获取
- 增量侦听

还有一个常见的工程问题是

- 应对服务发现故障

当服务发现服务（比如 etcd, consul, nacos等）出现问题的时候，我们不要去修改已经获取到的 endpoints 列表，从而可以更好的确保 etcd 等宕机后所依赖的服务依然可以正常交互。

#### 存量获取

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2fc0a889be0421883d707493e327527~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

当 `Service A` 启动时，需要从 `Service Registry` 获取 `Service B` 的已有节点列表：`Service B1`, `Service B2`, `Service B3`，然后根据自己的负载均衡算法来选择合适的节点发送请求。

#### 增量侦听

上图已经有了 `Service B1`, `Service B2`, `Service B3`，如果此时又启动了 `Service B4`，那么我们就需要通知 `Service A` 有个新增的节点。如图：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71497af0435442e3acffff9dfd67cb86~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

#### 应对服务发现故障

对于服务调用方来说，我们都会在内存里缓存一个可用节点列表。不管是使用 `etcd`，`consul` 或者 `nacos` 等，我们都可能面临服务发现集群故障，以 `etcd` 为例，当遇到 `etcd` 故障时，我们就需要冻结 `Service B` 的节点信息而不去变更，此时一定不能去清空节点信息，一旦清空就无法获取了，而此时 `Service B` 的节点很可能都是正常的，并且 `go-zero` 会自动隔离和恢复故障节点。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5af33ecc71dc44639825092ea0a81e4f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

对服务发现模式的介绍：[微服务中服务注册和发现的可行性方案 - 掘金 (juejin.cn)](https://juejin.cn/post/7028348724447281189?searchId=202403092351383768936C87D074711FFA)

## 框架推荐

### Go-zero

go-zero（收录于 CNCF 云原生技术全景图：https://landscape.cncf.io/?selected=go-zero）是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。

![img](https://raw.githubusercontent.com/zeromicro/zero-doc/main/doc/images/go-zero.png)

[GitHub](https://github.com/zeromicro/go-zero)

[官方文档](https://go-zero.dev/)

[go-zero-looklook](https://github.com/Mikaelemmmm/go-zero-looklook)

### Kitex

Kitex [kaɪt’eks] 字节跳动内部的 Golang 微服务 RPC 框架，具有**高性能**、**强可扩展**的特点，在字节内部已广泛使用。如果对微服务性能有要求，又希望定制扩展融入自己的治理体系，Kitex 会是一个不错的选择。

[Github](https://github.com/cloudwego/kitex)

[官方文档](https://www.cloudwego.io/zh/docs/kitex/)

[biz-demo](https://github.com/cloudwego/biz-demo)

### 学习项目推荐

Herzt&Kitex：[ViolaPioggia/GoYin: 第六届字节跳动青训营后端极简版抖音（二等奖🥈） (github.com)](https://github.com/ViolaPioggia/GoYin)

（万神🤩）

Go-zero：[GophersTeam/GopherTok: Gopher小队的极简抖音 (github.com)](https://github.com/GophersTeam/GopherTok) （显哥🥰）

## 阅读

[Thrift & IDL 介绍 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903971086139400)

[写给go开发者的gRPC教程-protobuf基础 - 掘金 (juejin.cn)](https://juejin.cn/post/7191008929986379836)

## 作业

阅读你感兴趣的框架文档 尝试读懂推荐项目代码 学会写IDL文件

学有余力可以写demo练手 :) （无需提交）

